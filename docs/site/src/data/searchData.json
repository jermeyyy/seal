[
  {
    "id": "Demo/demo",
    "title": "Demo",
    "route": "/Demo/demo",
    "content": "\n\nconst cloneRunCode = `# Clone the repository\ngit clone https://github.com/jermeyyy/seal.git\ncd seal\n\n# Run the Android demo app\n./gradlew :composeApp:installDebug\n\n# Run on iOS (macOS only)\nopen iosApp/iosApp.xcodeproj`\n\nconst demoAppCode = `// The demo app showcases CT verification in action\nval client = HttpClient(OkHttp) {\n    install(CertificateTransparency) {\n        // Verify all hosts\n        + \n        \n        // Log results\n        logger = { host, result ->\n            println( )\n        }\n    }\n}\n\n// Make a request and see CT results in the logs\nval response = client.get( Status: \\${response.status} CT verification passed! >Running the Demo</h2>\n        \n        <h3>Prerequisites</h3>\n        <ul>\n          <li>JDK 17+ and Android SDK</li>\n          <li>Android Studio or IntelliJ IDEA</li>\n          <li>For iOS: macOS with Xcode installed</li>\n        </ul>\n\n        <h3>Clone and Run</h3>\n        <CodeBlock code={cloneRunCode} language= >Code Example from Demo</h2>\n        \n        <h3>Main CT Configuration</h3>\n        <CodeBlock code={demoAppCode} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Explore More</h2>\n        <ul>\n          <li><a href= >Demo Source Code</a> — Full implementation on GitHub</li>\n          <li><Link to= >Getting Started</Link> — Set up Seal in your project</li>\n          <li><Link to= >OkHttp Guide</Link> — Detailed OkHttp integration</li>\n          <li><Link to="
  },
  {
    "id": "GettingStarted/gettingstarted",
    "title": "Getting Started",
    "route": "/GettingStarted/gettingstarted",
    "content": ">Installation</h2>\n\n        <p>\n          Seal supports both Kotlin Multiplatform and native Android projects. Choose the setup that matches your project.\n        </p>\n\n        <h3 id= >Kotlin Multiplatform Setup</h3>\n        <p>\n          For KMP projects targeting Android and iOS, add all relevant Seal modules:\n        </p>\n\n        <h4 id= >Version Catalog</h4>\n        <CodeBlock code={versionCatalogConfig} language= gradle/libs.versions.toml kmp-gradle-dependencies >Native Android Setup</h3>\n        <p>\n          For Android-only projects using OkHttp, you only need the core and Android modules:\n        </p>\n\n        <h4 id= >Version Catalog</h4>\n        <CodeBlock code={androidVersionCatalogConfig} language= gradle/libs.versions.toml android-gradle-dependencies  />\n      </section>\n\n      <section>\n        <h2 id= >Quick Start with OkHttp</h2>\n        <p>\n          For Android projects using OkHttp, add the CT network interceptor:\n        </p>\n        <CodeBlock code={okhttpBasicExample} language= >Quick Start with Ktor</h2>\n        <p>\n          For Kotlin Multiplatform projects using Ktor, install the CT plugin:\n        </p>\n        <CodeBlock code={ktorBasicExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Platform Requirements</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Platform</th>\n              <th>Minimum Version</th>\n              <th>HTTP Client</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Android</td>\n              <td>API 21+</td>\n              <td>OkHttp / Ktor (OkHttp engine)</td>\n            </tr>\n            <tr>\n              <td>iOS</td>\n              <td>iOS 13+</td>\n              <td>Ktor (Darwin engine)</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Available Modules</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Module</th>\n              <th>Description</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>seal-core</code></td>\n              <td>Core CT verification logic, models, log list parsing, and policies</td>\n            </tr>\n            <tr>\n              <td><code>seal-android</code></td>\n              <td>Android-specific: OkHttp interceptor, Conscrypt SCT extraction</td>\n            </tr>\n            <tr>\n              <td><code>seal-ios</code></td>\n              <td>iOS-specific: SecTrust integration, Darwin networking support</td>\n            </tr>\n            <tr>\n              <td><code>seal-ktor</code></td>\n              <td>Ktor plugin for multiplatform CT verification</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <p>\n          Now that you have basic CT verification running, explore more:\n        </p>\n        <ul>\n          <li>\n            <Link to= >OkHttp Integration</Link> — Full guide for Android OkHttp setup\n          </li>\n          <li>\n            <Link to= >Ktor Integration</Link> — Multiplatform Ktor plugin guide\n          </li>\n          <li>\n            <Link to= >Custom Policies</Link> — Chrome and Apple CT policies\n          </li>\n          <li>\n            <Link to= >Configuration</Link> — All available configuration options\n          </li>\n          <li>\n            <Link to="
  },
  {
    "id": "Guides/Configuration/configuration",
    "title": "Configuration",
    "route": "/Guides/Configuration/configuration",
    "content": ">Full Configuration Example</h2>\n        <p>\n          Here  />\n      </section>\n\n      <section>\n        <h2 id= >Host Patterns</h2>\n        <p>\n          Control which hosts undergo CT verification using inclusion and exclusion operators:\n        </p>\n        <table>\n          <thead>\n            <tr>\n              <th>Pattern</th>\n              <th>Description</th>\n              <th>Example</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>+ </code></td>\n              <td>Include all subdomains</td>\n              <td>Matches <code>www.example.com</code>, <code>api.example.com</code></td>\n            </tr>\n            <tr>\n              <td><code>+ </code></td>\n              <td>Include specific host</td>\n              <td>Matches only <code>www.example.com</code></td>\n            </tr>\n            <tr>\n              <td><code>- >CT Policy</h2>\n        <p>\n          Set the Certificate Transparency policy to use for verification:\n        </p>\n        <ul>\n          <li><code>ChromeCtPolicy()</code> — Default. Uses Google Chrome s CT requirements.</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Failure Modes</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Setting</th>\n              <th>Behavior</th>\n              <th>Use Case</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td><code>failOnError = false</code></td>\n              <td>Log failure, allow request (fail-open)</td>\n              <td>Initial deployment, monitoring</td>\n            </tr>\n            <tr>\n              <td><code>failOnError = true</code></td>\n              <td>Throw exception, block request (fail-closed)</td>\n              <td>Strict enforcement, security-critical apps</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Log List Configuration</h2>\n        <p>\n          Seal fetches the list of trusted CT logs to verify SCTs against. You can \n          configure the source and caching:\n        </p>\n        <ul>\n          <li>\n            <code>logListUrl</code> — URL to fetch the CT log list from. \n            Defaults to Google >Next Steps</h2>\n        <ul>\n          <li><Link to= >OkHttp Integration</Link> — Apply configuration with OkHttp</li>\n          <li><Link to= >Ktor Integration</Link> — Apply configuration with Ktor</li>\n          <li><Link to="
  },
  {
    "id": "Guides/CustomPolicies/custompolicies",
    "title": "Custom Policies",
    "route": "/Guides/CustomPolicies/custompolicies",
    "content": ">What is a CT Policy?</h2>\n        <p>\n          A CT Policy defines the rules for determining whether a certificate has \n          sufficient Certificate Transparency coverage. Different vendors (Google, Apple) \n          have different requirements for how many SCTs (Signed Certificate Timestamps) \n          a certificate needs and from which logs they must come.\n        </p>\n      </section>\n\n      <section>\n        <h2 id= >Chrome CT Policy</h2>\n        <p>\n          The Chrome CT Policy is the default policy used by Seal. It mirrors the \n          requirements that Google Chrome uses for CT enforcement:\n        </p>\n        <ul>\n          <li>Requires SCTs from multiple independent CT logs</li>\n          <li>SCTs must come from logs that are currently trusted</li>\n          <li>Number of required SCTs depends on certificate lifetime</li>\n          <li>At least one SCT must be from a Google-operated log and one from a non-Google log</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Apple CT Policy</h2>\n        <p>\n          The Apple CT Policy follows Apple >Using Policies</h2>\n        <CodeBlock code={customPolicyExample} language= >Creating a Custom Policy</h2>\n        <p>\n          <code>CTPolicy</code> is a <code>fun interface</code> with a single <code>evaluate</code> method, \n          making it easy to create your own policy — either as a class or a lambda.\n        </p>\n        <p>\n          The <code>evaluate</code> method receives two parameters:\n        </p>\n        <ul>\n          <li><code>certificateLifetimeDays</code> — the lifetime of the certificate in days, useful for scaling SCT requirements</li>\n          <li><code>sctResults</code> — a list of <code>SctVerificationResult</code> values, each either <code>Valid</code> (with the SCT and log operator) or an <code>Invalid</code> subtype such as <code>FailedVerification</code>, <code>LogNotTrusted</code>, <code>LogExpired</code>, <code>LogRejected</code>, or <code>SignatureMismatch</code></li>\n        </ul>\n        <p>\n          The method returns a <code>VerificationResult</code>: either <code>Success.Trusted</code> with the \n          valid SCTs, or a <code>Failure</code> variant such as <code>NoScts</code>, <code>TooFewSctsTrusted</code>, \n          <code>TooFewDistinctOperators</code>, or <code>LogServersFailed</code>.\n        </p>\n\n        <CodeBlock code={customPolicyCreationExample} language= Custom Policy Implementation Using a Custom Policy >Policy Comparison</h2>\n        <table>\n          <thead>\n            <tr>\n              <th>Feature</th>\n              <th>Chrome Policy</th>\n              <th>Apple Policy</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Default in Seal</td>\n              <td>Yes</td>\n              <td>No</td>\n            </tr>\n            <tr>\n              <td>Log diversity</td>\n              <td>Google + non-Google</td>\n              <td>Apple requirements</td>\n            </tr>\n            <tr>\n              <td>Lifetime-based SCT count</td>\n              <td>Yes</td>\n              <td>Yes</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Configuration Reference</Link> — All available options</li>\n          <li><Link to= >OkHttp Integration</Link> — Apply policies with OkHttp</li>\n          <li><Link to="
  },
  {
    "id": "Guides/Ktor/ktor",
    "title": "Ktor",
    "route": "/Guides/Ktor/ktor",
    "content": ">Basic Setup</h2>\n        <p>\n          Install the <code>CertificateTransparency</code> plugin on your Ktor HTTP client:\n        </p>\n        <CodeBlock code={ktorBasicExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Configuration DSL</h2>\n        <p>\n          Configure host patterns, error handling, and logging:\n        </p>\n        <CodeBlock code={ktorDslExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Multiplatform Support</h2>\n        <p>\n          The same Ktor configuration works on both platforms. Seal automatically \n          uses the appropriate engine for each platform:\n        </p>\n        <CodeBlock code={ktorMultiplatformExample} language= Multiplatform Configuration >Engine Selection</h2>\n        <p>\n          When using Ktor on Android, make sure you >Next Steps</h2>\n        <ul>\n          <li><Link to= >OkHttp Integration</Link> — Direct OkHttp interceptor usage</li>\n          <li><Link to= >iOS Integration</Link> — iOS-specific details</li>\n          <li><Link to="
  },
  {
    "id": "Guides/OkHttp/okhttp",
    "title": "Ok Http",
    "route": "/Guides/OkHttp/okhttp",
    "content": ">Basic Setup</h2>\n        <p>\n          Add the <code>seal-android</code> dependency and create an OkHttp client with \n          the CT interceptor:\n        </p>\n        <CodeBlock code={okhttpBasicExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Network vs Application Interceptor</h2>\n        <p>\n          Seal <strong>must</strong> be added as a network interceptor, not an application interceptor. \n          Network interceptors have access to the TLS connection, which is required \n          to extract SCTs (Signed Certificate Timestamps) from the TLS handshake.\n        </p>\n        <CodeBlock code={okhttpNetworkInterceptorNote} language= Important: Use Network Interceptor t have access to the TLS connection details.</p>\n        </div>\n      </section>\n\n      <section>\n        <h2 id= >Configuration DSL</h2>\n        <p>\n          The interceptor builder supports a rich DSL for configuring host patterns, \n          error handling, and logging:\n        </p>\n        <CodeBlock code={okhttpDslExample} language= OkHttp Configuration DSL >Host Inclusion & Exclusion</h2>\n        <p>\n          Control which hosts are verified using inclusion and exclusion patterns:\n        </p>\n        <ul>\n          <li><code>+ </code> — Include all subdomains of google.com</li>\n          <li><code>+ </code> — Include a specific host</li>\n          <li><code>- </code> — Exclude a specific host</li>\n          <li>Exclusions take precedence over inclusions</li>\n          <li>If no inclusions are specified, all hosts are included by default</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Error Handling</h2>\n        <p>\n          Seal supports two failure modes:\n        </p>\n        <ul>\n          <li>\n            <strong>Fail-open (default):</strong> <code>failOnError = false</code> — \n            CT verification failures are logged but don >Next Steps</h2>\n        <ul>\n          <li><Link to= >Ktor Integration</Link> — For multiplatform HTTP clients</li>\n          <li><Link to= >Custom Policies</Link> — Chrome vs Apple CT policies</li>\n          <li><Link to="
  },
  {
    "id": "Guides/iOS/ios",
    "title": "i O S",
    "route": "/Guides/iOS/ios",
    "content": ">How CT Works on iOS</h2>\n        <p>\n          On iOS, Certificate Transparency verification leverages the platform s built-in CT support</li>\n          <li>Works with URLSession-based networking (Ktor Darwin engine)</li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Ktor Darwin Engine Setup</h2>\n        <p>\n          The recommended way to use Seal on iOS is through the Ktor Darwin engine:\n        </p>\n        <CodeBlock code={iosUrlSessionExample} language=  />\n      </section>\n\n      <section>\n        <h2 id= >Platform Considerations</h2>\n        <ul>\n          <li>\n            <strong>Minimum iOS version:</strong> iOS 13+ is required for full SecTrust CT support\n          </li>\n          <li>\n            <strong>App Transport Security:</strong> ATS provides baseline security. \n            Seal adds explicit CT verification on top of ATS.\n          </li>\n          <li>\n            <strong>Background networking:</strong> CT verification works with background \n            URLSession tasks.\n          </li>\n        </ul>\n      </section>\n\n      <section>\n        <h2 id= >Next Steps</h2>\n        <ul>\n          <li><Link to= >Ktor Integration</Link> — Full multiplatform Ktor guide</li>\n          <li><Link to= >Configuration Reference</Link> — All available options</li>\n          <li><Link to="
  },
  {
    "id": "Home",
    "title": "Home",
    "route": "/Home",
    "content": " />\n          <img src= >View on GitHub</a>\n        </div>\n      </section>\n\n      {/* Overview */}\n      <section>\n        <h2 id= >Overview</h2>\n        <p>\n          <strong>Seal</strong> is a Certificate Transparency (CT) verification library for \n          Kotlin Multiplatform. It enforces CT compliance on HTTPS connections, ensuring that \n          TLS certificates are logged in public transparency logs. Seal supports Android and iOS, \n          with integrations for both OkHttp and Ktor HTTP clients.\n        </p>\n      </section>\n\n      {/* Why Seal */}\n      <section>\n        <h2 id= >Why Seal?</h2>\n        <p>\n          Certificate Transparency is a modern approach to securing the web >Show Me The Code!</h2>\n        <p style={{ marginBottom:  >Resources</h2>\n        <ul>\n          <li><Link to= >Why Certificate Transparency?</Link> — Understanding CT and its advantages</li>\n          <li><Link to= >Getting Started Guide</Link> — Installation and basic setup</li>\n          <li><Link to= >OkHttp Integration</Link> — Full OkHttp interceptor guide</li>\n          <li><Link to= >Ktor Integration</Link> — Multiplatform Ktor plugin guide</li>\n          <li><Link to= >Configuration</Link> — All configuration options</li>\n          <li><Link to= >Demo Application</Link> — See Seal in action</li>\n          <li><a href="
  },
  {
    "id": "WhyCT/whyct",
    "title": "Why C T",
    "route": "/WhyCT/whyct",
    "content": ">How the Web PKI Works</h2>\n        <p>\n          The Web Public Key Infrastructure (PKI) underpins secure communication on the internet.\n          When you visit a website over HTTPS, your browser verifies the site http://www.w3.org/2000/svg Web PKI certificate chain diagram  />\n            <text x= var(--color-text-primary) >Domain</text>\n            <text x= var(--color-text-secondary) >Owner</text>\n\n            {/* Arrow 1 */}\n            <line x1= var(--color-text-secondary)  />\n            <text x= var(--color-text-secondary) >CSR</text>\n\n            {/* CA */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Certificate</text>\n            <text x= var(--color-text-secondary) >Authority (CA)</text>\n\n            {/* Arrow 2 */}\n            <line x1= var(--color-text-secondary)  />\n            <text x= var(--color-text-secondary) >Signs</text>\n\n            {/* Certificate */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Certificate</text>\n            <text x= var(--color-text-secondary) >(X.509)</text>\n\n            {/* Arrow 3 */}\n            <line x1= var(--color-text-secondary)  />\n            <text x= var(--color-text-secondary) >Verifies</text>\n\n            {/* Browser */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Browser /</text>\n            <text x= var(--color-text-secondary) >Client</text>\n\n            {/* Trust Store */}\n            <rect x=  />\n            <text x= var(--color-text-secondary) >Trust Store</text>\n            <line x1=  />\n\n            <defs>\n              <marker id= >\n                <polygon points= var(--color-text-secondary) >The Problem: Certificate Misissuance</h2>\n        <p>\n          The trust model described above has a critical weakness: it relies entirely on CAs behaving\n          correctly. If a CA is compromised, coerced, or simply makes an error, it can issue a\n          certificate for <strong>any</strong> domain — and there is no built-in mechanism for domain\n          owners or the public to detect it.\n        </p>\n        <p>\n          This is not a theoretical risk. Notable real-world incidents include:\n        </p>\n        <ul>\n          <li>\n            <strong>DigiNotar (2011)</strong> — A Dutch CA was fully compromised. Attackers issued\n            fraudulent certificates for <code>*.google.com</code> and hundreds of other domains.\n            The certificates were used for MitM attacks against users in Iran. DigiNotar was\n            subsequently removed from all trust stores and went bankrupt.\n          </li>\n          <li>\n            <strong>Symantec (2015–2017)</strong> — Google discovered that Symantec had misissued\n            over 30,000 certificates, including certificates that violated the Baseline Requirements.\n            Symantec >Traditional Approach: SSL/Certificate Pinning</h2>\n        <p>\n          One early attempt to mitigate certificate misissuance is <strong>certificate pinning</strong> (also\n          called SSL pinning or public key pinning). The idea is straightforward: an application hardcodes\n          the expected certificate or public key hash for a given domain. During the TLS handshake, the\n          app compares the server http://www.w3.org/2000/svg SSL pinning flow diagram  />\n            <text x= var(--color-text-primary) >Mobile App</text>\n            <text x= var(--color-text-secondary) >(hardcoded pins)</text>\n\n            {/* Arrow 1: App → Server (TLS Handshake) */}\n            <line x1= var(--color-text-secondary)  />\n            <circle cx= >1</text>\n            <text x= var(--color-text-secondary) >TLS Handshake</text>\n\n            {/* Server */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Server</text>\n            <text x= var(--color-text-secondary) >(presents cert)</text>\n\n            {/* Arrow 2: Server → App (cert received, dashed) */}\n            <path d= var(--color-text-secondary)  />\n            <circle cx= >2</text>\n            <text x= var(--color-text-secondary) >Cert received</text>\n\n            {/* Arrow 3: App → Decision (compare pin) */}\n            <path d= var(--color-text-secondary)  />\n            <circle cx= >3</text>\n            <text x= var(--color-text-secondary) >Compare pin</text>\n\n            {/* Decision diamond */}\n            <polygon points=  />\n            <text x= var(--color-text-primary) >Pin</text>\n            <text x= var(--color-text-primary) >Match?</text>\n\n            {/* Yes path */}\n            <line x1= url(#arrowhead-green) >Yes</text>\n            <rect x=  />\n            <text x= >Allow</text>\n\n            {/* No path */}\n            <line x1=  />\n            <text x= >No</text>\n            <rect x=  />\n            <text x= >Block</text>\n\n            <defs>\n              <marker id= >\n                <polygon points= var(--color-text-secondary) >\n                <polygon points=  />\n              </marker>\n              <marker id= >\n                <polygon points= >The OCSP Approach</h2>\n        <p>\n          The Online Certificate Status Protocol (<code>OCSP</code>) provides a way for clients to\n          check whether a certificate has been revoked. Instead of downloading large Certificate\n          Revocation Lists (CRLs), the client sends a query to an OCSP responder — a server operated\n          by the CA — and receives a signed response indicating the certificate http://www.w3.org/2000/svg >\n            {/* Client */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Client</text>\n            <text x= var(--color-text-secondary) >(Browser / App)</text>\n\n            {/* Arrow 1: Client → Server */}\n            <line x1= var(--color-text-secondary) >1</text>\n            <text x= var(--color-text-secondary) >TLS Handshake</text>\n\n            {/* Server */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Server</text>\n            <text x= var(--color-text-secondary) >(presents cert)</text>\n\n            {/* Arrow 2: Client → OCSP (below) */}\n            <path d= var(--color-text-secondary) >2</text>\n            <text x= var(--color-text-secondary) </text>\n\n            {/* OCSP Responder */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >OCSP</text>\n            <text x= var(--color-text-secondary) >Responder</text>\n\n            {/* Arrow 3: OCSP → CA */}\n            <line x1= var(--color-text-secondary) >3</text>\n            <text x= var(--color-text-secondary) >Check</text>\n            <text x= var(--color-text-secondary) >revocation</text>\n\n            {/* CA */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Certificate</text>\n            <text x= var(--color-text-secondary) >Authority</text>\n\n            {/* Arrow 4: OCSP → Client (dashed return) */}\n            <path d= var(--color-text-secondary)  />\n            <circle cx= >4</text>\n            <text x= var(--color-text-secondary) </text>\n\n            <defs>\n              <marker id= >\n                <polygon points= var(--color-text-secondary) certificate-transparency >\n            RFC 6962\n          </a>{ http://www.w3.org/2000/svg Certificate Transparency ecosystem diagram  />\n            <text x= var(--color-text-primary) >Domain</text>\n            <text x= var(--color-text-secondary) >Owner</text>\n\n            {/* Arrow 1: Domain → CA */}\n            <line x1= var(--color-text-secondary)  />\n            <circle cx= >1</text>\n\n            {/* CA */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Certificate</text>\n            <text x= var(--color-text-secondary) >Authority</text>\n\n            {/* Arrow 4: CA → Certificate (with SCTs) */}\n            <line x1= var(--color-text-secondary)  />\n            <circle cx= >4</text>\n\n            {/* Certificate (with embedded SCTs) */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Certificate</text>\n            <text x= var(--color-text-secondary) >(with embedded</text>\n            <text x= var(--color-text-secondary) >SCTs)</text>\n\n            {/* Arrow 2: CA → CT Logs (submit precertificate) */}\n            <line x1= var(--color-text-secondary)  />\n            <circle cx= >2</text>\n            <text x= var(--color-text-secondary) >Submit precertificate</text>\n\n            {/* Arrow 3: CT Logs → CA (return SCTs) */}\n            <line x1= var(--color-text-secondary)  />\n            <circle cx= >3</text>\n            <text x= var(--color-text-secondary) >Return SCTs</text>\n\n            {/* CT Logs */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >CT Logs</text>\n            <text x= var(--color-text-secondary) >(append-only)</text>\n\n            {/* Arrow 5: Certificate → Browser (TLS handshake) */}\n            <line x1= var(--color-text-secondary)  />\n            <circle cx= >5</text>\n            <text x= var(--color-text-secondary) >TLS handshake</text>\n            <text x= var(--color-text-secondary) >with SCTs</text>\n\n            {/* Browser / Client */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Browser / Client</text>\n            <text x= var(--color-text-secondary) >(verifies SCTs)</text>\n\n            {/* Step 6 label */}\n            <circle cx= >6</text>\n            <text x= var(--color-text-secondary) >Verify SCTs against</text>\n            <text x= var(--color-text-secondary) >known CT log keys</text>\n\n            {/* Monitors */}\n            <rect x=  />\n            <text x= var(--color-text-primary) >Monitors</text>\n            <text x= var(--color-text-secondary) >(watch for fraud)</text>\n\n            {/* Arrow 7: Monitors → CT Logs (continuously audit) */}\n            <line x1= var(--color-text-secondary)  />\n            <circle cx= >7</text>\n            <text x= var(--color-text-secondary) >Continuously</text>\n            <text x= var(--color-text-secondary) >audit logs</text>\n\n            {/* Alert: Monitors → Domain Owner */}\n            <path d= url(#arrowhead-alert)  />\n            <text x= >Alert on unauthorized certificates</text>\n\n            <defs>\n              <marker id= >\n                <polygon points= var(--color-text-secondary) >\n                <polygon points= >How CT Works, Step by Step</h3>\n        <ul>\n          <li>\n            <strong>Step 1:</strong> A website owner requests a certificate from a CA.\n          </li>\n          <li>\n            <strong>Step 2:</strong> The CA creates a <strong>precertificate</strong> (containing a\n            poison extension that prevents browsers from accepting it directly) and submits it to one\n            or more CT logs.\n          </li>\n          <li>\n            <strong>Step 3:</strong> Each CT log returns a <strong>Signed Certificate Timestamp</strong>{ }\n            (<code>SCT</code>) — a cryptographic promise to include the certificate in the log within\n            the Maximum Merge Delay (typically 24 hours).\n          </li>\n          <li>\n            <strong>Step 4:</strong> The CA embeds the <code>SCT</code>s in the final certificate as\n            X.509v3 extensions and issues it to the domain owner.\n          </li>\n          <li>\n            <strong>Step 5:</strong> During the TLS handshake, the server presents the certificate with\n            its embedded <code>SCT</code>s to the client.\n          </li>\n          <li>\n            <strong>Step 6:</strong> The browser or client verifies the <code>SCT</code>s by checking\n            the signatures against the public keys of known CT logs.\n          </li>\n          <li>\n            <strong>Step 7:</strong> Independently, monitors continuously scan CT logs for certificates\n            issued for domains they watch. If an unauthorized certificate appears, the domain owner\n            is alerted.\n          </li>\n        </ul>\n\n        <h3 id= }\n            <a href= >\n              Merkle tree proofs\n            </a>.\n          </li>\n          <li>\n            <strong>Early detection of misissued certificates:</strong> Domain owners and monitors can\n            discover fraudulent certificates shortly after issuance — not months later.\n          </li>\n          <li>\n            <strong>No app updates required:</strong> Unlike pinning, CT does not require shipping new\n            application binaries when certificates change.\n          </li>\n          <li>\n            <strong>No connection-time latency:</strong> Unlike OCSP, <code>SCT</code>s are embedded in\n            the certificate itself — there is no extra network round-trip.\n          </li>\n          <li>\n            <strong>Enforced by major browsers:</strong> Chrome has required CT for all publicly trusted\n            certificates since April 2018. Safari enforces CT as well. Non-compliant certificates are\n            rejected.\n          </li>\n          <li>\n            <strong>Cryptographic integrity:</strong> CT logs use Merkle trees to provide append-only,\n            tamper-evident data structures. Any attempt to modify or remove a log entry is detectable.\n          </li>\n          <li>\n            <strong>Ecosystem-wide protection:</strong> CT protects all users of the web, not just\n            individual applications. Any domain owner can monitor logs for certificates issued in\n            their name.\n          </li>\n        </ul>\n      </section>\n\n      {/* ── Section 6: Comparison Table ──────────────────────────────── */}\n      <section>\n        <h2 id= >CT vs SSL Pinning: Comparison</h2>\n        <p>\n          The following table summarizes the key differences between SSL pinning and Certificate\n          Transparency as approaches to TLS security:\n        </p>\n\n        <table>\n          <thead>\n            <tr>\n              <th>Aspect</th>\n              <th>SSL Pinning</th>\n              <th>Certificate Transparency</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr>\n              <td>Risk of bricking app</td>\n              <td><strong style={{ color:   }}>High</strong> — cert rotation breaks pinned apps</td>\n              <td><strong style={{ color:   }}>None</strong> — no hardcoded values</td>\n            </tr>\n            <tr>\n              <td>Maintenance burden</td>\n              <td><strong style={{ color:   }}>High</strong> — manual pin rotation</td>\n              <td><strong style={{ color:   }}>Low</strong> — automatic via log ecosystem</td>\n            </tr>\n            <tr>\n              <td>Detects misissued certs</td>\n              <td><strong style={{ color:   }}>No</strong> — only validates known pins</td>\n              <td><strong style={{ color:   }}>Yes</strong> — all certs are publicly logged</td>\n            </tr>\n            <tr>\n              <td>Requires app updates</td>\n              <td><strong style={{ color:   }}>Yes</strong> — for every pin change</td>\n              <td><strong style={{ color:   }}>No</strong> — verification is automatic</td>\n            </tr>\n            <tr>\n              <td>Browser enforcement</td>\n              <td><strong style={{ color:   }}>No</strong> — app-level only</td>\n              <td><strong style={{ color:   }}>Yes</strong> — Chrome, Safari require CT</td>\n            </tr>\n            <tr>\n              <td>Protection scope</td>\n              <td>Single app only</td>\n              <td>Entire ecosystem</td>\n            </tr>\n            <tr>\n              <td>Operational complexity</td>\n              <td><strong style={{ color:   }}>High</strong> — coordination across platforms</td>\n              <td><strong style={{ color:   }}>Low</strong> — handled by infrastructure</td>\n            </tr>\n            <tr>\n              <td>Connection latency</td>\n              <td>None (but pins can be stale)</td>\n              <td>None (SCTs embedded in cert)</td>\n            </tr>\n          </tbody>\n        </table>\n      </section>\n\n      {/* ── Section 7: How Seal Implements CT ───────────────────────── */}\n      <section>\n        <h2 id= }\n            <code>SCT</code>s on every HTTPS connection.\n          </li>\n          <li>\n            <strong>A Ktor client plugin</strong> for Kotlin Multiplatform projects that adds CT\n            verification across Android and iOS.\n          </li>\n          <li>\n            <strong>Configurable verification policies</strong> — choose how many <code>SCT</code>s\n            are required, which CT logs to trust, and how to handle verification failures.\n          </li>\n          <li>\n            <strong>A shared core library</strong> (<code>seal-core</code>) implementing{"
  }
]